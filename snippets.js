//2 - TO ADD THE SNIPPETS ON A NEW CHROME INSTANCE
//In the new chrome open the inspector,  then open again from there press ctr+shift+I

let importSnippets = [
    {
        "name": "CLS",
        "content": "let cumulativeLayoutShiftScore = 0;\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (!entry.hadRecentInput) {\n      cumulativeLayoutShiftScore += entry.value;\n    }\n  }\n});\n \nobserver.observe({ type: \"layout-shift\", buffered: true });\n \ndocument.addEventListener(\"visibilitychange\", () => {\n  if (document.visibilityState === \"hidden\") {\n    observer.takeRecords();\n    observer.disconnect();\n \n    console.log(`CLS: ${cumulativeLayoutShiftScore}`);\n  }\n});"
    },
    {
        "name": "Get the LCP element",
        "content": "const po = new PerformanceObserver((list) => {\n  let entries = list.getEntries();\n \n  entries = dedupe(entries, \"startTime\");\n \n  entries.forEach((item, i) => {\n    console.dir(item);\n    console.log(\n      `${i + 1} current LCP item : ${item.element}: ${item.startTime}`,\n    );\n    item.element ? (item.element.style = \"border: 5px dotted lime;\") : \"\";\n  });\n \n  const lastEntry = entries[entries.length - 1];\n  console.log(`LCP is: ${lastEntry.startTime}`);\n});\n \npo.observe({ type: \"largest-contentful-paint\", buffered: true });\n \nfunction dedupe(arr, key) {\n  return [...new Map(arr.map((item) => [item[key], item])).values()];\n}"
    },
    {
        "name": "Lazy Images",
        "content": "// List all lazily loaded images above the fold\n// https://webperf-snippets.nucliweb.net\nfunction findAboveTheFoldLazyLoadedImages() {\n  const lazy = document.querySelectorAll('[loading=\"lazy\"]');\n  let lazyImages = [];\n  \n  lazy.forEach((tag) => {\n    const {x, y} = tag.getBoundingClientRect();\n    const position = parseInt(tag.getBoundingClientRect().top);\n \n    if(x < window.innerWidth && y < window.innerHeight && x !== 0 && y !== 0) {\n      lazyImages = [...lazyImages, tag];\n      console.log(tag);\n    }\n  });\n \n  if( lazyImages.length === 0 ) {\n    console.log(\n      `%c Good job, the site does not have any lazily loaded images in the viewport.`,\n      \"background: #222; color: lightgreen; padding: 0.5ch\",\n    );\n  }\n}\n \nfindAboveTheFoldLazyLoadedImages();"
    },
    {
        "name": "LCP SubParts",
        "content": "const LCP_SUB_PARTS = [\n  \"Time to first byte\",\n  \"Resource load delay\",\n  \"Resource load time\",\n  \"Element render delay\",\n];\n \nnew PerformanceObserver((list) => {\n  const lcpEntry = list.getEntries().at(-1);\n  const navEntry = performance.getEntriesByType(\"navigation\")[0];\n  const lcpResEntry = performance\n    .getEntriesByType(\"resource\")\n    .filter((e) => e.name === lcpEntry.url)[0];\n \n  const ttfb = navEntry.responseStart;\n  const lcpRequestStart = Math.max(\n    ttfb,\n    lcpResEntry ? lcpResEntry.requestStart || lcpResEntry.startTime : 0,\n  );\n  const lcpResponseEnd = Math.max(\n    lcpRequestStart,\n    lcpResEntry ? lcpResEntry.responseEnd : 0,\n  );\n  const lcpRenderTime = Math.max(\n    lcpResponseEnd,\n    lcpEntry ? lcpEntry.startTime : 0,\n  );\n \n  LCP_SUB_PARTS.forEach((part) => performance.clearMeasures(part));\n \n  const lcpSubPartMeasures = [\n    performance.measure(LCP_SUB_PARTS[0], {\n      start: 0,\n      end: ttfb,\n    }),\n    performance.measure(LCP_SUB_PARTS[1], {\n      start: ttfb,\n      end: lcpRequestStart,\n    }),\n    performance.measure(LCP_SUB_PARTS[2], {\n      start: lcpRequestStart,\n      end: lcpResponseEnd,\n    }),\n    performance.measure(LCP_SUB_PARTS[3], {\n      start: lcpResponseEnd,\n      end: lcpRenderTime,\n    }),\n  ];\n \n  // Log helpful debug information to the console.\n  console.log(\"LCP value: \", lcpRenderTime);\n  console.log(\"LCP element: \", lcpEntry.element, lcpEntry?.url);\n  console.table(\n    lcpSubPartMeasures.map((measure) => ({\n      \"LCP sub-part\": measure.name,\n      \"Time (ms)\": measure.duration,\n      \"% of LCP\": `${\n        Math.round((1000 * measure.duration) / lcpRenderTime) / 10\n      }%`,\n    })),\n  );\n}).observe({ type: \"largest-contentful-paint\", buffered: true });"
    },
    {
        "name": "LCP Image Entropy",
        "content": "console.table(\n  [...document.images]\n    .filter(\n      (img) => img.currentSrc != \"\" && !img.currentSrc.includes(\"data:image\"),\n    )\n    .map((img) => [\n      img.currentSrc,\n      (performance.getEntriesByName(img.currentSrc)[0]?.encodedBodySize * 8) /\n        (img.width * img.height),\n    ])\n    .filter((img) => img[1] !== 0),\n);"
    },
    {
        "name": "Interactions",
        "content": "const valueToRating = (score) =>\n  score <= 200 ? \"good\" : score <= 500 ? \"needs-improvement\" : \"poor\";\n \nconst COLOR_GOOD = \"#0CCE6A\";\nconst COLOR_NEEDS_IMPROVEMENT = \"#FFA400\";\nconst COLOR_POOR = \"#FF4E42\";\nconst RATING_COLORS = {\n  good: COLOR_GOOD,\n  \"needs-improvement\": COLOR_NEEDS_IMPROVEMENT,\n  poor: COLOR_POOR,\n};\n \nconst observer = new PerformanceObserver((list) => {\n  const interactions = {};\n \n  for (const entry of list\n    .getEntries()\n    .filter((entry) => !entry.interactionId)) {\n    interactions[entry.interactionId] = interactions[entry.interactionId] || [];\n    interactions[entry.interactionId].push(entry);\n  }\n \n  // Will report as a single interaction even if parts are in separate frames.\n  // Consider splitting by animation frame.\n  for (const interaction of Object.values(interactions)) {\n    const entry = interaction.reduce((prev, curr) =>\n      prev.duration >= curr.duration ? prev : curr,\n    );\n    const value = entry.duration;\n    const rating = valueToRating(value);\n \n    const formattedValue = `${value.toFixed(0)} ms`;\n    console.groupCollapsed(\n      `Interaction tracking snippet %c${formattedValue} (${rating})`,\n      `color: ${RATING_COLORS[rating] || \"inherit\"}`,\n    );\n    console.log(\"Interaction target:\", entry.target);\n \n    for (let entry of interaction) {\n      console.log(\n        `Interaction event type: %c${entry.name}`,\n        \"font-family: monospace\",\n      );\n \n      // RenderTime is an estimate, because duration is rounded, and may get rounded down.\n      // In rare cases it can be less than processingEnd and that breaks performance.measure().\n      // Lets make sure its at least 4ms in those cases so you can just barely see it.\n      const adjustedPresentationTime = Math.max(\n        entry.processingEnd + 4,\n        entry.startTime + entry.duration,\n      );\n \n      console.table([\n        {\n          subPartString: \"Input delay\",\n          \"Time (ms)\": Math.round(entry.processingStart - entry.startTime, 0),\n        },\n        {\n          subPartString: \"Processing time\",\n          \"Time (ms)\": Math.round(\n            entry.processingEnd - entry.processingStart,\n            0,\n          ),\n        },\n        {\n          subPartString: \"Presentation delay\",\n          \"Time (ms)\": Math.round(\n            adjustedPresentationTime - entry.processingEnd,\n            0,\n          ),\n        },\n      ]);\n    }\n \n    console.groupEnd();\n  }\n});\n \nobserver.observe({\n  type: \"event\",\n  durationThreshold: 0, // 16 minimum by spec\n  buffered: true,\n});"
    },
    {
        "name": "Layout Shift Loading",
        "content": "new PerformanceObserver((entryList) => {\n  console.log(entryList.getEntries());\n}).observe({ type: \"layout-shift\", buffered: true });"
    },
    {
        "name": "Long Animation Frames",
        "content": "(function init() {\n  function processAndFilterLoAFs(entries) {\n    function floorObject(o) {\n      return Object.fromEntries(\n        Array.from(Object.entries(o)).map(([key, value]) => [\n          key,\n          typeof value === \"number\" ? Math.floor(value) : value,\n        ]),\n      );\n    }\n \n    function processEntry(entry) {\n      const startTime = entry.startTime;\n      const endTime = entry.startTime + entry.duration;\n      const delay = entry.desiredRenderStart\n        ? Math.max(0, entry.startTime - entry.desiredRenderStart)\n        : 0;\n      const deferredDuration = Math.max(\n        0,\n        entry.desiredRenderStart - entry.startTime,\n      );\n      const renderDuration = entry.styleAndLayoutStart - entry.renderStart;\n      const workDuration = entry.renderStart\n        ? entry.renderStart - entry.startTime\n        : entry.duration;\n      const totalForcedStyleAndLayoutDuration = entry.scripts.reduce(\n        (sum, script) => sum + script.forcedStyleAndLayoutDuration,\n        0,\n      );\n      const styleAndLayoutDuration = entry.styleAndLayoutStart\n        ? endTime - entry.styleAndLayoutStart\n        : 0;\n      const scripts = entry.scripts.map((script) => {\n        const delay = script.startTime - script.desiredExecutionStart;\n        const scriptEnd = script.startTime + script.duration;\n        const compileDuration = script.executionStart - script.startTime;\n        const execDuration = scriptEnd - script.executionStart;\n        return floorObject({\n          delay,\n          compileDuration,\n          execDuration,\n          ...script.toJSON(),\n        });\n      });\n      return floorObject({\n        startTime,\n        delay,\n        deferredDuration,\n        renderDuration,\n        workDuration,\n        styleAndLayoutDuration,\n        totalForcedStyleAndLayoutDuration,\n        ...entry.toJSON(),\n        scripts,\n      });\n    }\n \n    return entries.map(processEntry);\n  }\n \n  function analyze() {\n    return loafs\n      .map((loaf) => ({\n        blockingDuration: loaf.blockingDuration,\n        loaf,\n        scripts: loaf.scripts,\n        events: events.filter((e) => overlap(e, loaf)),\n      }))\n      .filter((l) => l.blockingDuration && l.events.length);\n  }\n \n  let loafs = [];\n  let events = [];\n  function processLoAFs(entries) {\n    loafs = [...loafs, ...processAndFilterLoAFs(entries.getEntries())];\n    console.log(analyze());\n  }\n \n  function processEvents(entries) {\n    events = [...events, ...entries.getEntries()];\n    console.log(analyze());\n  }\n  new PerformanceObserver(processLoAFs).observe({\n    type: \"long-animation-frame\",\n    buffered: true,\n  });\n  new PerformanceObserver(processEvents).observe({\n    type: \"event\",\n    buffered: true,\n  });\n \n  function overlap(e1, e2) {\n    return (\n      e1.startTime < e2.startTime + e2.duration &&\n      e2.startTime < e1.startTime + e1.duration\n    );\n  }\n  window.whynp = analyze;\n})();"
    },
    {
        "name": "Long Task",
        "content": "try {\n  const po = new PerformanceObserver((list) => {\n    const numLongTasks = list.getEntries().length;\n    for (const entry of list.getEntries()) {\n      console.table(entry.toJSON());\n    }\n    console.log(\n      `%cNum. Long Tasks: ${numLongTasks}`,\n      \"color: #FF4E42; font-weight: bold\",\n    );\n  });\n  po.observe({ type: \"longtask\", buffered: true });\n} catch (e) {\n  console.error(`The browser doesn't support this API`);\n}"
    },
    {
        "name": "TTFB from Server",
        "content": "// Measure the time to first byte of all the resources loaded\n// https://webperf-snippets.nucliweb.net\nnew PerformanceObserver((entryList) => {\n  const [pageNav] = entryList.getEntriesByType(\"navigation\");\n  console.log(`TTFB (ms): ${pageNav.responseStart}`);\n}).observe({\n  type: \"navigation\",\n  buffered: true,\n});"
    },
    {
        "name": "TTFB Sub Parts",
        "content": "(() => {\n \n  const formatTime = (time) => {\n    //round by 2 decimals, use Math.round() for integer\n    return Math.round(time * 100) / 100;\n  };\n \n  new PerformanceObserver((entryList) => {\n    const [pageNav] = entryList.getEntriesByType('navigation');\n \n    // timing start times are relative\n    const activationStart = pageNav.activationStart || 0;\n    const waitEnd = Math.max((pageNav.workerStart || pageNav.fetchStart) - activationStart, 0);\n    const dnsStart = Math.max(pageNav.domainLookupStart - activationStart, 0);\n    const tcpStart = Math.max(pageNav.connectStart - activationStart, 0);\n    const sslStart = Math.max(pageNav.secureConnectionStart - activationStart, 0);\n    const tcpEnd = Math.max(pageNav.connectEnd - activationStart, 0);\n    const responseStart = Math.max(pageNav.responseStart - activationStart, 0);\n \n    // attribution based on https://www.w3.org/TR/navigation-timing-2/#processing-model\n    // use associative array to log the results more readable\n    let attributionArray = [];\n    attributionArray['Redirect and Waiting duration'] = {'time in ms':formatTime(waitEnd)};\n    attributionArray['Worker and Cache duration'] = {'time in ms':formatTime(dnsStart - waitEnd)};\n    attributionArray['DNS duration'] = {'time in ms':formatTime(tcpStart - dnsStart)};\n    attributionArray['TCP duration'] = {'time in ms':formatTime(sslStart - tcpStart)};\n    attributionArray['SSL duration'] = {'time in ms':formatTime(tcpEnd - sslStart)};\n    attributionArray['Request duration'] = {'time in ms':formatTime(responseStart - tcpEnd)};\n    attributionArray['Total TTFB'] = {'time in ms':formatTime(responseStart)};\n \n    // log the results\n    console.log('%cTime to First Byte ('+formatTime(responseStart - activationStart)+'ms)', 'color: blue; font-weight: bold;');\n    console.table(attributionArray);\n \n    console.log('%cOrigininal navigation entry', 'color: blue; font-weight: bold;');\n    console.log(pageNav);\n \n  }).observe({\n    type: 'navigation',\n    buffered: true\n  });\n})();"
    },
    {
        "name": "TTFB all resources",
        "content": "// Measure the time to first byte of all the resources loaded\n// https://webperf-snippets.nucliweb.net\nnew PerformanceObserver((entryList) => {\n  const entries = entryList.getEntries();\n  const resourcesLoaded = [...entries]\n    .map((entry) => {\n      let obj = {};\n      // Some resources may have a responseStart value of 0, due\n      // to the resource being cached, or a cross-origin resource\n      // being served without a Timing-Allow-Origin header set.\n \n      if (entry.responseStart > 0) {\n        obj = {\n          \"TTFB (ms)\": +entry.responseStart.toFixed(2),\n          Resource: entry.name,\n        };\n      }\n      return Object.keys(obj).length > 0 ? obj : undefined;\n    })\n    .filter((item) => item !== undefined);\n \n  console.table(resourcesLoaded);\n}).observe({\n  type: \"resource\",\n  buffered: true,\n});"
    },
    {
        "name": "Render Blocking Resources",
        "content": "function RenderBlocking({\n  startTime,\n  duration,\n  responseEnd,\n  name,\n  initiatorType,\n}) {\n  this.startTime = startTime;\n  this.duration = duration;\n  this.responseEnd = responseEnd;\n  this.name = name;\n  this.initiatorType = initiatorType;\n}\n \nfunction findRenderBlockingResources() {\n  return window.performance\n    .getEntriesByType(\"resource\")\n    .filter(({ renderBlockingStatus }) => renderBlockingStatus === \"blocking\")\n    .map(\n      ({ startTime, duration, responseEnd, name, initiatorType }) =>\n        new RenderBlocking({\n          startTime,\n          duration,\n          responseEnd,\n          name,\n          initiatorType,\n        }),\n    );\n}\n \nconsole.table(findRenderBlockingResources());"
    },
    {
        "name": "Content Visibility",
        "content": "(() => {\n \n  // Create an object to store the results\n  let ret = {\n    autoTable: [],\n    autoNodeArray: []\n  };\n \n \n  // Get the name of the node\n  function getName(node) {\n    const name = node.nodeName;\n    return node.nodeType === 1\n      ? name.toLowerCase()\n      : name.toUpperCase().replace(/^#/, '');\n  }\n \n  // Get the selector\n  const getSelector = (node) => {\n    let sel = '';\n \n    try {\n      while (node && node.nodeType !== 9) {\n        const el = node;\n        const part = el.id\n          ? '#' + el.id\n          : getName(el) +\n          (el.classList &&\n            el.classList.value &&\n            el.classList.value.trim() &&\n            el.classList.value.trim().length\n            ? '.' + el.classList.value.trim().replace(/\\s+/g, '.')\n            : '');\n        if (sel.length + part.length > (100) - 1) return sel || part;\n        sel = sel ? part + '>' + sel : part;\n        if (el.id) break;\n        node = el.parentNode;\n      }\n    } catch (err) {\n      // Do nothing...\n    }\n    return sel;\n  };\n \n  const getNodesWithContentVisibility = (node) => {\n    // Get the computed style\n    let cs = window.getComputedStyle(node);\n    let cv = cs['content-visibility'];\n \n    // If we find content-visibility: auto, add it to the table\n    if (cv && cv === 'auto') {\n      ret.autoTable.push({ selector: getSelector(node), ContentVisibility: cs['content-visibility'] });\n      ret.autoNodeArray.push(node);\n    }\n \n    // Recursively call this function for each child node\n    for (let i = 0; i < node.children.length; i++) {\n      getNodesWithContentVisibility(node.children[i]);\n    }\n  }\n \n  // find all content-visibility: auto\n  getNodesWithContentVisibility(document.body);\n \n  // Display the results in the console\n  if (ret.autoTable.length === 0) {\n    console.log('%cNo content-visibility: auto found. Consider applying content-visibility: auto to offscreen content (the footer perhaps?)', 'color: orange; font-weight: bold;');\n  } else {\n    console.log('%cContent-visibility: auto selectors', 'color: green; font-weight: bold;');\n    console.table(ret.autoTable);\n \n    console.log('%cNodeList for you to inspect (harder to read but more info)', 'color: green; font-weight: bold;');\n    console.log(ret.autoNodeArray);\n  }\n})()"
    },
    {
        "name": "Event Procesing time",
        "content": "const events = new Map([\n  [\"connectTime\", { start: \"connectStart\", end: \"connectEnd\" }],\n  [\"domainLookupTime\", { start: \"domainLookupStart\", end: \"domainLookupEnd\" }],\n  [\n    \"DOMContentLoaded\",\n    { start: \"domContentLoadedEventStart\", end: \"domContentLoadedEventEnd\" }\n  ],\n \n  [\"onload\", { start: \"loadEventStart\", end: \"loadEventEnd\" }]\n]);\n \nconst observer = new PerformanceObserver((list) => {\n  const displayTimes = [];\n  list.getEntries().forEach((entry) => {\n    console.log(entry);\n    for (const [key, value] of events) {\n      const endValue = entry[value.end];\n      const startValue = entry[value.start];\n \n      const eventTime = endValue - startValue;\n \n      displayTimes.push({\n        url: entry.name,\n        event: key,\n        processingTime: `${eventTime.toFixed(2)} ms`\n      });\n    }\n  });\n \n  console.table(displayTimes);\n});\n \nobserver.observe({ type: \"navigation\", buffered: true });"
    },
    {
        "name": "Find Above The Fold Lazy Loaded Images",
        "content": "// List all lazily loaded images above the fold\n// https://webperf-snippets.nucliweb.net\nfunction findAboveTheFoldLazyLoadedImages() {\n  const lazy = document.querySelectorAll('[loading=\"lazy\"]');\n  let lazyImages = [];\n  \n  lazy.forEach((tag) => {\n    const {x, y} = tag.getBoundingClientRect();\n    const position = parseInt(tag.getBoundingClientRect().top);\n \n    if(x < window.innerWidth && y < window.innerHeight && x !== 0 && y !== 0) {\n      lazyImages = [...lazyImages, tag];\n      console.log(tag);\n    }\n  });\n \n  if( lazyImages.length === 0 ) {\n    console.log(\n      `%c Good job, the site does not have any lazily loaded images in the viewport.`,\n      \"background: #222; color: lightgreen; padding: 0.5ch\",\n    );\n  }\n}\n \nfindAboveTheFoldLazyLoadedImages();"
    },
    {
        "name": "Find Images With Loading Lazy and Fetchpriority",
        "content": "const MESSAGES = {\n  good: `The current rendered code, don't have elements with loading=\"lazy\" fetchpriority=\"high\"`,\n  bad: \"In reality you probably wouldnt really want `loading=lazy` and `fetchpriority=high` at the same time. That would mean don't load it initially, but when you start to load it, load it with high priority. Which is kind of contradictory!\",\n};\nconst elementsLazyFetchpriority = document.querySelectorAll(\n  \"[loading=lazy][fetchpriority=high]\",\n);\nconst numLazyFetchpriority = elementsLazyFetchpriority.length;\nconst hasLazyFetchpriority = numLazyFetchpriority > 0;\n \nif (hasLazyFetchpriority) {\n  console.log(\n    `%c The page has ${numLazyFetchpriority} image(s) with loading=\"lazy\" fetchpriority=\"high\"`,\n    \"background: #222; color: lightcoral; padding: 0.5ch; font-size: 1.28em\",\n  );\n  elementsLazyFetchpriority.forEach((el) => console.log(el));\n \n  console.log(\n    `%c ${MESSAGES.bad}`,\n    \"background: #222; color: lightcoral; padding: 0.5ch; margin-top: 1em\",\n  );\n} else {\n  console.log(\n    `%c ${MESSAGES.good}`,\n    \"background: #222; color: lightgreen; padding: 0.5ch\",\n  );\n}"
    },
    {
        "name": "Find non Lazy Loaded Images outside of the viewport",
        "content": "// Execute it after the page has loaded without any user interaction (Scroll, click, etc)\nfunction isInViewport(tag) {\n  let rect = tag.getBoundingClientRect();\n  return (\n    rect.bottom >= 0 &&\n    rect.right >= 0 &&\n    rect.top <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.left <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n \nfunction findImgCanidatesForLazyLoading() {\n  let notLazyImages = document.querySelectorAll(\n    'img:not([data-src]):not([loading=\"lazy\"])'\n  );\n  const notLazyImagesOutOfViewport = Array.from(notLazyImages).filter((tag) => !isInViewport(tag));\n \n  if( notLazyImagesOutOfViewport.length === 0 ) {\n    console.log(\n      `%c Good job, the site has al the images out of the viewport with lazyloading.`,\n      \"background: #222; color: lightgreen; padding: 0.5ch\",\n    );\n  } else {\n    console.log(\n      `%c Consider lazyloading the following images`,\n      \"background: #222; color: lightcoral; padding: 0.5ch; margin-top: 1em\",\n    );\n    notLazyImagesOutOfViewport.forEach((img) => console.log(img));\n  }\n  \n}\n \nfindImgCanidatesForLazyLoading();"
    },
    {
        "name": "First And Third Party Script Info",
        "content": "// ex: katespade.com - list firsty party subdomains in HOSTS array\nconst HOSTS = [\"assets.katespade.com\"];\n \nfunction getScriptInfo() {\n  const resourceListEntries = performance.getEntriesByType(\"resource\");\n  // set for first party scripts\n  const first = [];\n  // set for third party scripts\n  const third = [];\n \n  resourceListEntries.forEach((resource) => {\n    // check for initiator type\n    const value = \"initiatorType\" in resource;\n    if (value) {\n      if (resource.initiatorType === \"script\") {\n        const { host } = new URL(resource.name);\n        // check if resource url host matches location.host = first party script\n        if (host === location.host || HOSTS.includes(host)) {\n          const json = resource.toJSON();\n          first.push({ ...json, type: \"First Party\" });\n        } else {\n          // add to third party script\n          const json = resource.toJSON();\n          third.push({ ...json, type: \"Third Party\" });\n        }\n      }\n    }\n  });\n \n  const scripts = {\n    firstParty: [{ name: \"no data\" }],\n    thirdParty: [{ name: \"no data\" }],\n  };\n \n  if (first.length) {\n    scripts.firstParty = first;\n  }\n \n  if (third.length) {\n    scripts.thirdParty = third;\n  }\n \n  return scripts;\n}\n \nconst { firstParty, thirdParty } = getScriptInfo();\n \nconsole.groupCollapsed(\"FIRST PARTY SCRIPTS\");\nconsole.table(firstParty);\nconsole.groupEnd();\n \nconsole.groupCollapsed(\"THIRD PARTY SCRIPTS\");\nconsole.table(thirdParty);\nconsole.groupEnd();"
    },
    {
        "name": "First And Third Party Script Timings",
        "content": "function createUniqueLists(firstParty, thirdParty) {\n  function getUniqueListBy(arr, key) {\n    return [...new Map(arr.map((item) => [item[key], item])).values()];\n  }\n \n  const firstPartyList = getUniqueListBy(firstParty, [\"name\"]);\n  const thirdPartyList = getUniqueListBy(thirdParty, [\"name\"]);\n \n  return { firstPartyList, thirdPartyList };\n}\n \nconst { firstPartyList, thirdPartyList } = createUniqueLists(\n  firstParty,\n  thirdParty,\n);\n \nfunction calculateTimings(party, type) {\n  const partyChoice = party === \"first\" ? firstParty : thirdParty;\n \n  const timingChoices = {\n    DNS_TIME: [\"domainLookupEnd\", \"domainLookupStart\"],\n    TCP_HANDSHAKE: [\"connectEnd\", \"connectStart\"],\n    RESPONSE_TIME: [\"responseEnd\", \"responseStart\"],\n    SECURE_CONNECTION_TIME: [\"connectEnd\", \"secureConnectionStart\", 0],\n    FETCH_UNTIL_RESPONSE: [\"responseEnd\", \"fetchStart\", 0],\n    REQ_START_UNTIL_RES_END: [\"responseEnd\", \"requestStart\", 0],\n    START_UNTIL_RES_END: [\"responseEnd\", \"startTime\", 0],\n    REDIRECT_TIME: [\"redirectEnd\", \"redirectStart\"],\n  };\n \n  function handleChoices(timingEnd, timingStart, num) {\n    if (!num) {\n      return timingEnd - timingStart;\n    }\n \n    if (timingStart > 0) {\n      return timingEnd - timingStart;\n    }\n \n    return 0;\n  }\n \n  const timings = partyChoice.map((script) => {\n    const [timingEnd, timingStart, num] = timingChoices[type];\n    const endValue = script[timingEnd];\n    const startValue = script[timingStart];\n    return {\n      name: script.name,\n      [type]: handleChoices(endValue, startValue, num),\n    };\n  });\n \n  return timings;\n}\n \n// Available Options\nconst timingOptions = [\n  \"DNS_TIME\",\n  \"TCP_HANDSHAKE\",\n  \"RESPONSE_TIME\",\n  \"SECURE_CONNECTION_TIME\",\n  \"FETCH_UNTIL_RESPONSE\",\n  \"REQ_START_UNTIL_RES_END\",\n  \"START_UNTIL_RES_END\",\n  \"REDIRECT_TIME\",\n];\n \n// run em all!\n// https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API#timing_resource_loading_phases\n \ntimingOptions.forEach((timing) => {\n  console.groupCollapsed(`FIRST PARTY: ${timing}`);\n  console.table(calculateTimings(\"first\", timing));\n  console.groupEnd();\n  console.groupCollapsed(`THIRD PARTY: ${timing}`);\n  console.table(calculateTimings(\"third\", timing));\n  console.groupEnd();\n});\n \n// choose your battle - arg1 is string either \"first\" or \"third\", arg2 is string timing option listed above.\n \nconsole.table(calculateTimings(\"first\", \"REQ_START_UNTIL_RES_END\"));"
    },
    {
        "name": "Fonts Preloaded, Loaded, and Used Above The Fold",
        "content": "const linkElements = document.querySelectorAll(`link[rel=\"preload\"]`);\nconst arrayLinks = Array.from(linkElements);\nconst preloadedFonts = arrayLinks.filter((link) => link.as === \"font\");\n \nconsole.log(\n  \"%cFonts Preloaded via Resources Hints\",\n  \"font-weight: bold; font-size: 1.2em; color: lightcoral\",\n);\npreloadedFonts.forEach((font) => console.log(`▸ ${font.href}`));\nconsole.log(\"\");\n \nconst loadedFonts = [\n  ...new Set(\n    Array.from(document.fonts.values())\n      .map((font) => font)\n      .filter((font) => font.status === \"loaded\")\n      .map((font) => `${font.family} - ${font.weight} - ${font.style}`),\n  ),\n];\n \nconsole.log(\n  \"%cFonts and Weights Loaded in the Document\",\n  \"font-weight: bold; font-size: 1.2em; color: lightcoral\",\n);\nloadedFonts.forEach((font) => console.log(`▸ ${font}`));\nconsole.log(\"\");\n \nconst childrenSlector =\n  \"body * > *:not(script):not(style):not(link):not(source)\";\nconst aboveFoldElements = Array.from(\n  document.querySelectorAll(childrenSlector),\n).filter((elm) => {\n  const rect = elm.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <=\n      (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n});\n \nconst usedFonts = Array.from(\n  new Set(\n    [...aboveFoldElements].map(\n      (e) =>\n        `${getComputedStyle(e).fontFamily} | ${\n          getComputedStyle(e).fontWeight\n        } | ${getComputedStyle(e).fontStyle}`,\n    ),\n  ),\n);\n \nconsole.log(\n  \"%cFonts and Weights Used Above the Fold\",\n  \"font-weight: bold; font-size: 1.2em; color: lightcoral\",\n);\nusedFonts.forEach((font) => console.log(`▸ ${font}`));"
    },
    {
        "name": "Get your <head> in order",
        "content": "(() => {\n  function $parcel$export(e, n, v, s) {\n    Object.defineProperty(e, n, {\n      get: v,\n      set: s,\n      enumerable: true,\n      configurable: true,\n    });\n  }\n  const $eb5be8077a65b10b$var$Hues = {\n    PINK: 320,\n    BLUE: 200,\n  };\n  function $eb5be8077a65b10b$export$921514c0345db5eb(hue) {\n    return [\n      `oklch(5% .1 ${hue})`,\n      `oklch(13% .2 ${hue})`,\n      `oklch(25% .2 ${hue})`,\n      `oklch(35% .25 ${hue})`,\n      `oklch(50% .27 ${hue})`,\n      `oklch(67% .31 ${hue})`,\n      `oklch(72% .25 ${hue})`,\n      `oklch(80% .2 ${hue})`,\n      `oklch(90% .1 ${hue})`,\n      `oklch(99% .05 ${hue})`,\n      \"#ccc\",\n    ];\n  }\n  const $eb5be8077a65b10b$export$e6952b12ade67489 = [\n    \"#9e0142\",\n    \"#d53e4f\",\n    \"#f46d43\",\n    \"#fdae61\",\n    \"#fee08b\",\n    \"#e6f598\",\n    \"#abdda4\",\n    \"#66c2a5\",\n    \"#3288bd\",\n    \"#5e4fa2\",\n    \"#cccccc\",\n  ];\n  const $eb5be8077a65b10b$export$d68d0fda4a10dbc2 =\n    $eb5be8077a65b10b$export$921514c0345db5eb($eb5be8077a65b10b$var$Hues.PINK);\n  const $eb5be8077a65b10b$export$738c3b9a44c87ecc =\n    $eb5be8077a65b10b$export$921514c0345db5eb($eb5be8077a65b10b$var$Hues.BLUE);\n  const $eb5be8077a65b10b$export$9a82c28ef488e918 = {\n    DEFAULT: $eb5be8077a65b10b$export$e6952b12ade67489,\n    PINK: $eb5be8077a65b10b$export$d68d0fda4a10dbc2,\n    BLUE: $eb5be8077a65b10b$export$738c3b9a44c87ecc,\n  };\n  function $eb5be8077a65b10b$export$18c940335d915715(elementColor) {\n    let invalidColor = \"#cccccc\";\n    if (elementColor == invalidColor) invalidColor = \"red\";\n    return `repeating-linear-gradient(45deg, ${elementColor}, ${elementColor} 3px, ${invalidColor} 3px, ${invalidColor} 6px)`;\n  }\n \n  var $d410929ede0a2ee4$exports = {};\n \n  $parcel$export(\n    $d410929ede0a2ee4$exports,\n    \"IO\",\n    () => $d410929ede0a2ee4$export$8f8422ac5947a789,\n  );\n \n  class $d410929ede0a2ee4$export$8f8422ac5947a789 {\n    constructor(document1, options, output = window.console) {\n      this.document = document1;\n      this.options = options;\n      this.console = output;\n      this.isStaticHead = false;\n      this.head = null;\n    }\n    async init() {\n      if (this.head) return;\n      if (this.options.prefersDynamicAssessment()) {\n        this.head = this.document.querySelector(\"head\");\n        return;\n      }\n      try {\n        let html = await this.getStaticHTML();\n        html = html.replace(/(\\<\\/?)(head)/gi, \"$1static-head\");\n        const staticDoc =\n          this.document.implementation.createHTMLDocument(\"New Document\");\n        staticDoc.documentElement.innerHTML = html;\n        this.head = staticDoc.querySelector(\"static-head\");\n        if (this.head) this.isStaticHead = true;\n        else this.head = this.document.head;\n      } catch (e) {\n        this.console.error(\n          `${this.options.loggingPrefix}An exception occurred while getting the static <head>:`,\n          e,\n        );\n        this.head = this.document.head;\n      }\n      if (!this.isStaticHead)\n        this.console.warn(\n          `${this.options.loggingPrefix}Unable to parse the static (server-rendered) <head>. Falling back to document.head`,\n          this.head,\n        );\n    }\n    async getStaticHTML() {\n      const url = this.document.location.href;\n      const response = await fetch(url);\n      return await response.text();\n    }\n    getHead() {\n      return this.head;\n    }\n    stringifyElement(element) {\n      return element.getAttributeNames().reduce((id, attr) => {\n        return (id += `[${CSS.escape(attr)}=${JSON.stringify(\n          element.getAttribute(attr),\n        )}]`);\n      }, element.nodeName);\n    }\n    getLoggableElement(element) {\n      if (!this.isStaticHead) return element;\n      const selector = this.stringifyElement(element);\n      const candidates = Array.from(\n        this.document.head.querySelectorAll(selector),\n      );\n      if (candidates.length == 0) return element;\n      if (candidates.length == 1) return candidates[0];\n      // The way the static elements are parsed makes their innerHTML different.\n      // Recreate the element in DOM and compare its innerHTML with those of the candidates.\n      // This ensures a consistent parsing and positive string matches.\n      const candidateWrapper = this.document.createElement(\"div\");\n      const elementWrapper = this.document.createElement(\"div\");\n      elementWrapper.innerHTML = element.innerHTML;\n      const candidate = candidates.find((c) => {\n        candidateWrapper.innerHTML = c.innerHTML;\n        return candidateWrapper.innerHTML == elementWrapper.innerHTML;\n      });\n      if (candidate) return candidate;\n      return element;\n    }\n    // Note: AI-generated function.\n    createElementFromSelector(selector) {\n      // Extract the tag name from the selector\n      const tagName = selector.match(/^[A-Za-z]+/)[0];\n      if (!tagName) return;\n      // Create the new element\n      const element = document.createElement(tagName);\n      // Extract the attribute key-value pairs from the selector\n      const attributes = selector.match(/\\[([A-Za-z-]+)=\"([^\"]+)\"\\]/g) || [];\n      // Set the attributes on the new element\n      attributes.forEach((attribute) => {\n        const [key, value] = attribute\n          .replace(\"[\", \"\")\n          .replace(\"]\", \"\")\n          .split(\"=\");\n        element.setAttribute(key, value.slice(1, -1));\n      });\n      return element;\n    }\n    logElementFromSelector({\n      weight: weight,\n      selector: selector,\n      innerHTML: innerHTML,\n      isValid: isValid,\n      customValidations: customValidations = {},\n    }) {\n      weight = +weight;\n      const viz = this.getElementVisualization(weight);\n      let element = this.createElementFromSelector(selector);\n      element.innerHTML = innerHTML;\n      element = this.getLoggableElement(element);\n      this.logElement({\n        viz: viz,\n        weight: weight,\n        element: element,\n        isValid: isValid,\n        customValidations: customValidations,\n      });\n    }\n    logElement({\n      viz: viz,\n      weight: weight,\n      element: element,\n      isValid: isValid,\n      customValidations: customValidations,\n      omitPrefix: omitPrefix = false,\n    }) {\n      if (!omitPrefix)\n        viz.visual = `${this.options.loggingPrefix}${viz.visual}`;\n      let loggingLevel = \"log\";\n      const args = [viz.visual, viz.style, weight + 1, element];\n      if (!this.options.isValidationEnabled()) {\n        this.console[loggingLevel](...args);\n        return;\n      }\n      const { payload: payload, warnings: warnings } = customValidations;\n      if (payload) args.push(payload);\n      if (warnings?.length) {\n        // Element-specific warnings.\n        loggingLevel = \"warn\";\n        warnings.forEach((warning) => args.push(`❌ ${warning}`));\n      } else if (\n        !isValid &&\n        (this.options.prefersDynamicAssessment() || this.isStaticHead)\n      ) {\n        // General warnings.\n        loggingLevel = \"warn\";\n        args.push(`❌ invalid element (${element.tagName})`);\n      }\n      this.console[loggingLevel](...args);\n    }\n    logValidationWarnings(warnings) {\n      if (!this.options.isValidationEnabled()) return;\n      warnings.forEach(\n        ({ warning: warning, elements: elements = [], element: element }) => {\n          elements = elements.map(this.getLoggableElement.bind(this));\n          this.console.warn(\n            `${this.options.loggingPrefix}${warning}`,\n            ...elements,\n            element || \"\",\n          );\n        },\n      );\n    }\n    getColor(weight) {\n      return this.options.palette[10 - weight];\n    }\n    getHeadVisualization(elements) {\n      let visual = \"\";\n      const styles = [];\n      elements.forEach(({ weight: weight, isValid: isValid }) => {\n        visual += \"%c \";\n        const color = this.getColor(weight);\n        let style = `padding: 5px; margin: 0 -1px; `;\n        if (isValid) style += `background-color: ${color};`;\n        else\n          style += `background-image: ${(0,\n          $eb5be8077a65b10b$export$18c940335d915715)(color)}`;\n        styles.push(style);\n      });\n      return {\n        visual: visual,\n        styles: styles,\n      };\n    }\n    getElementVisualization(weight) {\n      const visual = `%c${new Array(weight + 1).fill(\"█\").join(\"\")}`;\n      const color = this.getColor(weight);\n      const style = `color: ${color}`;\n      return {\n        visual: visual,\n        style: style,\n      };\n    }\n    visualizeHead(groupName, headElement, headWeights) {\n      const headViz = this.getHeadVisualization(headWeights);\n      this.console.groupCollapsed(\n        `${this.options.loggingPrefix}${groupName} %chead%c order\\n${headViz.visual}`,\n        \"font-family: monospace\",\n        \"font-family: inherit\",\n        ...headViz.styles,\n      );\n      headWeights.forEach(\n        ({\n          weight: weight,\n          element: element,\n          isValid: isValid,\n          customValidations: customValidations,\n        }) => {\n          const viz = this.getElementVisualization(weight);\n          this.logElement({\n            viz: viz,\n            weight: weight,\n            element: element,\n            isValid: isValid,\n            customValidations: customValidations,\n            omitPrefix: true,\n          });\n        },\n      );\n      this.console.log(\n        `${groupName} %chead%c element`,\n        \"font-family: monospace\",\n        \"font-family: inherit\",\n        headElement,\n      );\n      this.console.groupEnd();\n    }\n  }\n \n  var $5b739339de321a37$exports = {};\n \n  $parcel$export(\n    $5b739339de321a37$exports,\n    \"Options\",\n    () => $5b739339de321a37$export$c019608e5b5bb4cb,\n  );\n \n  class $5b739339de321a37$export$c019608e5b5bb4cb {\n    constructor({\n      preferredAssessmentMode:\n        preferredAssessmentMode = $5b739339de321a37$export$c019608e5b5bb4cb\n          .AssessmentMode.STATIC,\n      validation: validation = true,\n      palette: palette = $eb5be8077a65b10b$export$e6952b12ade67489,\n      loggingPrefix: loggingPrefix = \"Capo: \",\n    } = {}) {\n      this.setPreferredAssessmentMode(preferredAssessmentMode);\n      this.setValidation(validation);\n      this.setPalette(palette);\n      this.setLoggingPrefix(loggingPrefix);\n    }\n    static get AssessmentMode() {\n      return {\n        STATIC: \"static\",\n        DYNAMIC: \"dynamic\",\n      };\n    }\n    static get Palettes() {\n      return $eb5be8077a65b10b$export$9a82c28ef488e918;\n    }\n    prefersStaticAssessment() {\n      return (\n        this.preferredAssessmentMode ===\n        $5b739339de321a37$export$c019608e5b5bb4cb.AssessmentMode.STATIC\n      );\n    }\n    prefersDynamicAssessment() {\n      return (\n        this.preferredAssessmentMode ===\n        $5b739339de321a37$export$c019608e5b5bb4cb.AssessmentMode.DYNAMIC\n      );\n    }\n    isValidationEnabled() {\n      return this.validation;\n    }\n    setPreferredAssessmentMode(preferredAssessmentMode) {\n      if (!this.isValidAssessmentMode(preferredAssessmentMode))\n        throw new Error(\n          `Invalid option: preferred assessment mode, expected AssessmentMode.STATIC or AssessmentMode.DYNAMIC, got \"${preferredAssessmentMode}\".`,\n        );\n      this.preferredAssessmentMode = preferredAssessmentMode;\n    }\n    setPreferredAssessmentModeToStatic(prefersStatic) {\n      let mode =\n        $5b739339de321a37$export$c019608e5b5bb4cb.AssessmentMode.STATIC;\n      if (!prefersStatic)\n        mode = $5b739339de321a37$export$c019608e5b5bb4cb.AssessmentMode.DYNAMIC;\n      this.setPreferredAssessmentMode(mode);\n    }\n    setValidation(validation) {\n      if (!this.isValidValidation(validation))\n        throw new Error(\n          `Invalid option: validation, expected boolean, got \"${validation}\".`,\n        );\n      this.validation = validation;\n    }\n    setPalette(palette) {\n      if (!this.isValidPalette(palette))\n        throw new Error(\n          `Invalid option: palette, expected [${Object.keys(\n            $eb5be8077a65b10b$export$9a82c28ef488e918,\n          ).join(\"|\")}] or an array of colors, got \"${palette}\".`,\n        );\n      if (typeof palette === \"string\") {\n        this.palette = $eb5be8077a65b10b$export$9a82c28ef488e918[palette];\n        return;\n      }\n      this.palette = palette;\n    }\n    setLoggingPrefix(loggingPrefix) {\n      if (!this.isValidLoggingPrefix(loggingPrefix))\n        throw new Error(\n          `Invalid option: logging prefix, expected string, got \"${loggingPrefix}\".`,\n        );\n      this.loggingPrefix = loggingPrefix;\n    }\n    isValidAssessmentMode(assessmentMode) {\n      return Object.values(\n        $5b739339de321a37$export$c019608e5b5bb4cb.AssessmentMode,\n      ).includes(assessmentMode);\n    }\n    isValidValidation(validation) {\n      return typeof validation === \"boolean\";\n    }\n    isValidPalette(palette) {\n      if (typeof palette === \"string\")\n        return Object.keys($eb5be8077a65b10b$export$9a82c28ef488e918).includes(\n          palette,\n        );\n      if (!Array.isArray(palette)) return false;\n      return (\n        palette.length === 11 &&\n        palette.every((color) => typeof color === \"string\")\n      );\n    }\n    isValidLoggingPrefix(loggingPrefix) {\n      return typeof loggingPrefix === \"string\";\n    }\n    isPreferredPalette(palette) {\n      return JSON.stringify(this.palette) == JSON.stringify(palette);\n    }\n    valueOf() {\n      return {\n        preferredAssessmentMode: this.preferredAssessmentMode,\n        validation: this.validation,\n        palette: this.palette,\n        loggingPrefix: this.loggingPrefix,\n      };\n    }\n  }\n \n  var $9c3989fcb9437829$exports = {};\n \n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"ElementWeights\",\n    () => $9c3989fcb9437829$export$881088883fcab450,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"ElementDetectors\",\n    () => $9c3989fcb9437829$export$6ade8bb3620eb74b,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isMeta\",\n    () => $9c3989fcb9437829$export$daeb0db0c224decd,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isTitle\",\n    () => $9c3989fcb9437829$export$e55aad21605f020a,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isPreconnect\",\n    () => $9c3989fcb9437829$export$a3316bd0a640eb8b,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isAsyncScript\",\n    () => $9c3989fcb9437829$export$20e2051ffd813ee3,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isImportStyles\",\n    () => $9c3989fcb9437829$export$be443fc6335656f0,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isSyncScript\",\n    () => $9c3989fcb9437829$export$65983fc0a5543400,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isSyncStyles\",\n    () => $9c3989fcb9437829$export$9d6cdbffb13bee21,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isPreload\",\n    () => $9c3989fcb9437829$export$226ad5ba23be83f0,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isDeferScript\",\n    () => $9c3989fcb9437829$export$3d269f86e8bd1d24,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isPrefetchPrerender\",\n    () => $9c3989fcb9437829$export$4d2ed086e1fec499,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"META_HTTP_EQUIV_KEYWORDS\",\n    () => $9c3989fcb9437829$export$b7417cf4a2235f73,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isOriginTrial\",\n    () => $9c3989fcb9437829$export$38a04d482ec50f88,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"isMetaCSP\",\n    () => $9c3989fcb9437829$export$14b1a2f64a600585,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"getWeight\",\n    () => $9c3989fcb9437829$export$de32fe5d64aee40c,\n  );\n  $parcel$export(\n    $9c3989fcb9437829$exports,\n    \"getHeadWeights\",\n    () => $9c3989fcb9437829$export$5cc4a311ddbe699c,\n  );\n  const $9c3989fcb9437829$export$881088883fcab450 = {\n    META: 10,\n    TITLE: 9,\n    PRECONNECT: 8,\n    ASYNC_SCRIPT: 7,\n    IMPORT_STYLES: 6,\n    SYNC_SCRIPT: 5,\n    SYNC_STYLES: 4,\n    PRELOAD: 3,\n    DEFER_SCRIPT: 2,\n    PREFETCH_PRERENDER: 1,\n    OTHER: 0,\n  };\n  const $9c3989fcb9437829$export$6ade8bb3620eb74b = {\n    META: $9c3989fcb9437829$export$daeb0db0c224decd,\n    TITLE: $9c3989fcb9437829$export$e55aad21605f020a,\n    PRECONNECT: $9c3989fcb9437829$export$a3316bd0a640eb8b,\n    ASYNC_SCRIPT: $9c3989fcb9437829$export$20e2051ffd813ee3,\n    IMPORT_STYLES: $9c3989fcb9437829$export$be443fc6335656f0,\n    SYNC_SCRIPT: $9c3989fcb9437829$export$65983fc0a5543400,\n    SYNC_STYLES: $9c3989fcb9437829$export$9d6cdbffb13bee21,\n    PRELOAD: $9c3989fcb9437829$export$226ad5ba23be83f0,\n    DEFER_SCRIPT: $9c3989fcb9437829$export$3d269f86e8bd1d24,\n    PREFETCH_PRERENDER: $9c3989fcb9437829$export$4d2ed086e1fec499,\n  };\n  const $9c3989fcb9437829$export$b7417cf4a2235f73 = [\n    \"accept-ch\",\n    \"content-security-policy\",\n    \"content-type\",\n    \"default-style\",\n    \"delegate-ch\",\n    \"origin-trial\",\n    \"x-dns-prefetch-control\",\n  ];\n  function $9c3989fcb9437829$export$daeb0db0c224decd(element) {\n    const httpEquivSelector = $9c3989fcb9437829$export$b7417cf4a2235f73\n      .map((keyword) => {\n        return `[http-equiv=\"${keyword}\" i]`;\n      })\n      .join(\", \");\n    return element.matches(\n      `meta:is([charset], ${httpEquivSelector}, [name=viewport]), base`,\n    );\n  }\n  function $9c3989fcb9437829$export$e55aad21605f020a(element) {\n    return element.matches(\"title\");\n  }\n  function $9c3989fcb9437829$export$a3316bd0a640eb8b(element) {\n    return element.matches(\"link[rel=preconnect]\");\n  }\n  function $9c3989fcb9437829$export$20e2051ffd813ee3(element) {\n    return element.matches(\"script[src][async]\");\n  }\n  function $9c3989fcb9437829$export$be443fc6335656f0(element) {\n    const importRe = /@import/;\n    if (element.matches(\"style\")) return importRe.test(element.textContent);\n    /* TODO: Support external stylesheets.\n  if (element.matches('link[rel=stylesheet][href]')) {\n    let response = fetch(element.href);\n    response = response.text();\n    return importRe.test(response);\n  } */ return false;\n  }\n  function $9c3989fcb9437829$export$65983fc0a5543400(element) {\n    return element.matches(\n      \"script:not([src][defer],[src][type=module],[src][async],[type*=json])\",\n    );\n  }\n  function $9c3989fcb9437829$export$9d6cdbffb13bee21(element) {\n    return element.matches(\"link[rel=stylesheet],style\");\n  }\n  function $9c3989fcb9437829$export$226ad5ba23be83f0(element) {\n    return element.matches(\"link:is([rel=preload], [rel=modulepreload])\");\n  }\n  function $9c3989fcb9437829$export$3d269f86e8bd1d24(element) {\n    return element.matches(\n      \"script[src][defer], script:not([src][async])[src][type=module]\",\n    );\n  }\n  function $9c3989fcb9437829$export$4d2ed086e1fec499(element) {\n    return element.matches(\n      \"link:is([rel=prefetch], [rel=dns-prefetch], [rel=prerender])\",\n    );\n  }\n  function $9c3989fcb9437829$export$38a04d482ec50f88(element) {\n    return element.matches('meta[http-equiv=\"origin-trial\"i]');\n  }\n  function $9c3989fcb9437829$export$14b1a2f64a600585(element) {\n    return element.matches(\n      'meta[http-equiv=\"Content-Security-Policy\" i], meta[http-equiv=\"Content-Security-Policy-Report-Only\" i]',\n    );\n  }\n  function $9c3989fcb9437829$export$de32fe5d64aee40c(element) {\n    for (let [id, detector] of Object.entries(\n      $9c3989fcb9437829$export$6ade8bb3620eb74b,\n    )) {\n      if (detector(element))\n        return $9c3989fcb9437829$export$881088883fcab450[id];\n    }\n    return $9c3989fcb9437829$export$881088883fcab450.OTHER;\n  }\n  function $9c3989fcb9437829$export$5cc4a311ddbe699c(head) {\n    const headChildren = Array.from(head.children);\n    return headChildren.map((element) => {\n      return {\n        element: element,\n        weight: $9c3989fcb9437829$export$de32fe5d64aee40c(element),\n      };\n    });\n  }\n \n  var $580f7ed6bc170ae8$exports = {};\n \n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"VALID_HEAD_ELEMENTS\",\n    () => $580f7ed6bc170ae8$export$79e124b7caef7aa9,\n  );\n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"PRELOAD_SELECTOR\",\n    () => $580f7ed6bc170ae8$export$5540ac2a18901364,\n  );\n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"isValidElement\",\n    () => $580f7ed6bc170ae8$export$a8257692ac88316c,\n  );\n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"hasValidationWarning\",\n    () => $580f7ed6bc170ae8$export$eeefd08c3a6f8db7,\n  );\n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"getValidationWarnings\",\n    () => $580f7ed6bc170ae8$export$b01ab94d0cd042a0,\n  );\n  $parcel$export(\n    $580f7ed6bc170ae8$exports,\n    \"getCustomValidations\",\n    () => $580f7ed6bc170ae8$export$6c93e2175c028eeb,\n  );\n \n  const $580f7ed6bc170ae8$export$79e124b7caef7aa9 = new Set([\n    \"base\",\n    \"link\",\n    \"meta\",\n    \"noscript\",\n    \"script\",\n    \"style\",\n    \"template\",\n    \"title\",\n  ]);\n  const $580f7ed6bc170ae8$export$5540ac2a18901364 =\n    'link:is([rel=\"preload\" i], [rel=\"modulepreload\" i])';\n  function $580f7ed6bc170ae8$export$a8257692ac88316c(element) {\n    return $580f7ed6bc170ae8$export$79e124b7caef7aa9.has(\n      element.tagName.toLowerCase(),\n    );\n  }\n  function $580f7ed6bc170ae8$export$eeefd08c3a6f8db7(element) {\n    // Element itself is not valid.\n    if (!$580f7ed6bc170ae8$export$a8257692ac88316c(element)) return true;\n    // Children are not valid.\n    if (\n      element.matches(\n        `:has(:not(${Array.from($580f7ed6bc170ae8$export$79e124b7caef7aa9).join(\n          \", \",\n        )}))`,\n      )\n    )\n      return true;\n    // <title> is not the first of its type.\n    if (element.matches(\"title:is(:nth-of-type(n+2))\")) return true;\n    // <base> is not the first of its type.\n    if (element.matches(\"base:has(~ base), base ~ base\")) return true;\n    // CSP meta tag anywhere.\n    if ((0, $9c3989fcb9437829$export$14b1a2f64a600585)(element)) return true;\n    // Origin trial expired or cross-origin.\n    if ($580f7ed6bc170ae8$var$isInvalidOriginTrial(element)) return true;\n    // Preload is unnecessary.\n    if ($580f7ed6bc170ae8$var$isUnnecessaryPreload(element)) return true;\n    return false;\n  }\n  function $580f7ed6bc170ae8$export$b01ab94d0cd042a0(head) {\n    const validationWarnings = [];\n    const titleElements = Array.from(head.querySelectorAll(\"title\"));\n    const titleElementCount = titleElements.length;\n    if (titleElementCount != 1)\n      validationWarnings.push({\n        warning: `Expected exactly 1 <title> element, found ${titleElementCount}`,\n        elements: titleElements,\n      });\n    const baseElements = Array.from(head.querySelectorAll(\"base\"));\n    const baseElementCount = baseElements.length;\n    if (baseElementCount > 1)\n      validationWarnings.push({\n        warning: `Expected at most 1 <base> element, found ${baseElementCount}`,\n        elements: baseElements,\n      });\n    const metaCSP = head.querySelector(\n      'meta[http-equiv=\"Content-Security-Policy\" i]',\n    );\n    if (metaCSP)\n      validationWarnings.push({\n        warning:\n          \"CSP meta tags disable the preload scanner due to a bug in Chrome. Use the CSP header instead. Learn more: https://crbug.com/1458493\",\n        element: metaCSP,\n      });\n    head.querySelectorAll(\"*\").forEach((element) => {\n      if ($580f7ed6bc170ae8$export$a8257692ac88316c(element)) return;\n      let root = element;\n      while (root.parentElement != head) root = root.parentElement;\n      validationWarnings.push({\n        warning: `${element.tagName} elements are not allowed in the <head>`,\n        element: root,\n      });\n    });\n    const originTrials = Array.from(\n      head.querySelectorAll('meta[http-equiv=\"Origin-Trial\" i]'),\n    );\n    originTrials.forEach((element) => {\n      const metadata = $580f7ed6bc170ae8$var$validateOriginTrial(element);\n      if (metadata.warnings.length == 0) return;\n      validationWarnings.push({\n        warning: `Invalid origin trial token: ${metadata.warnings.join(\", \")}`,\n        elements: [element],\n        element: metadata.payload,\n      });\n    });\n    return validationWarnings;\n  }\n  function $580f7ed6bc170ae8$export$6c93e2175c028eeb(element) {\n    if ((0, $9c3989fcb9437829$export$38a04d482ec50f88)(element))\n      return $580f7ed6bc170ae8$var$validateOriginTrial(element);\n    if ((0, $9c3989fcb9437829$export$14b1a2f64a600585)(element))\n      return $580f7ed6bc170ae8$var$validateCSP(element);\n    if ($580f7ed6bc170ae8$var$isUnnecessaryPreload(element))\n      return $580f7ed6bc170ae8$var$validateUnnecessaryPreload(element);\n    return {};\n  }\n  function $580f7ed6bc170ae8$var$validateCSP(element) {\n    const warnings = [];\n    if (\n      element.matches(\n        'meta[http-equiv=\"Content-Security-Policy-Report-Only\" i]',\n      )\n    )\n      //https://w3c.github.io/webappsec-csp/#meta-element\n      warnings.push(\"CSP Report-Only is forbidden in meta tags\");\n    else if (element.matches('meta[http-equiv=\"Content-Security-Policy\" i]'))\n      warnings.push(\"meta CSP discouraged. See https://crbug.com/1458493.\");\n    return {\n      warnings: warnings,\n    };\n  }\n  function $580f7ed6bc170ae8$var$isInvalidOriginTrial(element) {\n    if (!(0, $9c3989fcb9437829$export$38a04d482ec50f88)(element)) return false;\n    const { warnings: warnings } =\n      $580f7ed6bc170ae8$var$validateOriginTrial(element);\n    return warnings.length > 0;\n  }\n  function $580f7ed6bc170ae8$var$validateOriginTrial(element) {\n    const metadata = {\n      payload: null,\n      warnings: [],\n    };\n    const token = element.getAttribute(\"content\");\n    try {\n      metadata.payload = $580f7ed6bc170ae8$var$decodeOriginTrialToken(token);\n      if (metadata.payload.expiry < new Date())\n        metadata.warnings.push(\"expired\");\n      if (\n        !metadata.payload.isThirdParty &&\n        !$580f7ed6bc170ae8$var$isSameOrigin(\n          metadata.payload.origin,\n          document.location.href,\n        )\n      )\n        metadata.warnings.push(\"invalid origin\");\n    } catch {\n      metadata.warnings.push(\"invalid token\");\n    }\n    return metadata;\n  }\n  // Adapted from https://glitch.com/~ot-decode.\n  function $580f7ed6bc170ae8$var$decodeOriginTrialToken(token) {\n    const buffer = new Uint8Array([...atob(token)].map((a) => a.charCodeAt(0)));\n    const view = new DataView(buffer.buffer);\n    const length = view.getUint32(65, false);\n    const payload = JSON.parse(\n      new TextDecoder().decode(buffer.slice(69, 69 + length)),\n    );\n    payload.expiry = new Date(payload.expiry * 1000);\n    return payload;\n  }\n  function $580f7ed6bc170ae8$var$isSameOrigin(a, b) {\n    return new URL(a).origin === new URL(b).origin;\n  }\n  function $580f7ed6bc170ae8$var$isUnnecessaryPreload(element) {\n    if (!element.matches($580f7ed6bc170ae8$export$5540ac2a18901364))\n      return false;\n    const href = element.getAttribute(\"href\");\n    if (!href) return false;\n    const preloadedUrl = $580f7ed6bc170ae8$var$absolutifyUrl(href);\n    return (\n      $580f7ed6bc170ae8$var$findElementWithSource(\n        element.parentElement,\n        preloadedUrl,\n      ) != null\n    );\n  }\n  function $580f7ed6bc170ae8$var$findElementWithSource(root, sourceUrl) {\n    const linksAndScripts = Array.from(\n      root.querySelectorAll(\n        `link:not(${$580f7ed6bc170ae8$export$5540ac2a18901364}), script`,\n      ),\n    );\n    return linksAndScripts.find((e) => {\n      const src = e.getAttribute(\"href\") || e.getAttribute(\"src\");\n      if (!src) return false;\n      return sourceUrl == $580f7ed6bc170ae8$var$absolutifyUrl(src);\n    });\n  }\n  function $580f7ed6bc170ae8$var$absolutifyUrl(href) {\n    return new URL(href, document.baseURI).href;\n  }\n  function $580f7ed6bc170ae8$var$validateUnnecessaryPreload(element) {\n    const href = element.getAttribute(\"href\");\n    const preloadedUrl = $580f7ed6bc170ae8$var$absolutifyUrl(href);\n    const preloadedElement = $580f7ed6bc170ae8$var$findElementWithSource(\n      element.parentElement,\n      preloadedUrl,\n    );\n    if (!preloadedElement)\n      throw new Error(\"Expected an invalid preload, but none found.\");\n    return {\n      warnings: [\n        `This preload has little to no effect. ${href} is already discoverable by another ${preloadedElement.tagName} element.`,\n      ],\n    };\n  }\n \n  function $0eec6c831ab0f90a$export$8679af897d1c058e(io, validation) {\n    const validationWarnings = validation.getValidationWarnings(io.getHead());\n    io.logValidationWarnings(validationWarnings);\n  }\n  function $0eec6c831ab0f90a$export$b65597cffe09aebc(io, validation, rules) {\n    const headElement = io.getHead();\n    const headWeights = rules\n      .getHeadWeights(headElement)\n      .map(({ element: element, weight: weight }) => {\n        return {\n          weight: weight,\n          element: io.getLoggableElement(element),\n          isValid: !validation.hasValidationWarning(element),\n          customValidations: validation.getCustomValidations(element),\n        };\n      });\n    io.visualizeHead(\"Actual\", headElement, headWeights);\n    const sortedWeights = Array.from(headWeights).sort(\n      (a, b) => b.weight - a.weight,\n    );\n    const sortedHead = document.createElement(\"head\");\n    sortedWeights.forEach(({ element: element }) => {\n      sortedHead.appendChild(element.cloneNode(true));\n    });\n    io.visualizeHead(\"Sorted\", sortedHead, sortedWeights);\n    return headWeights;\n  }\n \n  const $fd3091053c5dfffc$var$CAPO_GLOBAL = \"__CAPO__\";\n  async function $fd3091053c5dfffc$var$run() {\n    const options = new $5b739339de321a37$exports.Options(\n      self[$fd3091053c5dfffc$var$CAPO_GLOBAL],\n    );\n    const io = new $d410929ede0a2ee4$exports.IO(document, options);\n    await io.init();\n    $0eec6c831ab0f90a$export$8679af897d1c058e(io, $580f7ed6bc170ae8$exports);\n    $0eec6c831ab0f90a$export$b65597cffe09aebc(\n      io,\n      $580f7ed6bc170ae8$exports,\n      $9c3989fcb9437829$exports,\n    );\n  }\n  $fd3091053c5dfffc$var$run();\n})();"
    },
    {
        "name": "Inline CSS Info and Size",
        "content": "// Wait for the page to fully load\n \nfunction findAllInlineCSS() {\n  const convertToKb = (bytes) => bytes / 1000;\n  const inlineCSS = document.querySelectorAll(\"style\");\n  let totalByteSize = 0;\n  for (const css of [...inlineCSS]) {\n    const html = css.innerHTML;\n    const size = new Blob([html]).size;\n    css.byteSizeInKb = convertToKb(size);\n    totalByteSize += size;\n  }\n  // customize table here, can right click on header in console to sort table\n  console.table(inlineCSS, [\n    \"baseURI\",\n    \"parentElement\",\n    \"byteSizeInKb\",\n    \"innerHTML\",\n  ]);\n \n  console.log(`Total size: ${convertToKb(totalByteSize)} kB`);\n}\n \nfindAllInlineCSS();"
    },
    {
        "name": "Inline Script Info and Size",
        "content": "function findInlineScripts() {\n  const inlineScripts = document.querySelectorAll([\n    \"script:not([async]):not([defer]):not([src])\",\n  ]);\n  console.log(inlineScripts);\n  console.log(`COUNT: ${inlineScripts.length}`);\n  let totalByteSize = 0;\n  for (const script of [...inlineScripts]) {\n    const html = script.innerHTML;\n    const size = new Blob([html]).size;\n    totalByteSize += size;\n  }\n  console.log(totalByteSize / 1000 + \" kb\");\n}\n \nfindInlineScripts();"
    },
    {
        "name": "Inline Script Info and Size Including __NEXT_DATA__",
        "content": "function findInlineScriptsWithNextData() {\n  const inlineScripts = document.querySelectorAll([\n    \"script:not([async]):not([defer]):not([src])\",\n  ]);\n  console.log(inlineScripts);\n  console.log(`COUNT: ${inlineScripts.length}`);\n \n  const byteSize = {\n    NEXT_DATA_SIZE: 0,\n    OTHER_SIZE: 0,\n  };\n \n  function getSize(script) {\n    const html = script.innerHTML;\n    return new Blob([html]).size;\n  }\n \n  function convertToKb(bytes) {\n    return bytes / 1000;\n  }\n \n  for (const script of [...inlineScripts]) {\n    if (script.id == \"__NEXT_DATA__\") {\n      byteSize.NEXT_DATA_SIZE += getSize(script);\n    } else {\n      byteSize.OTHER_SIZE += getSize(script);\n    }\n  }\n \n  return {\n    NEXT_DATA_SIZE: convertToKb(byteSize.NEXT_DATA_SIZE) + \" kb\",\n    OTHER_SIZE: convertToKb(byteSize.OTHER_SIZE) + \" kb\",\n    totalByteSize:\n      convertToKb(byteSize.NEXT_DATA_SIZE) +\n      convertToKb(byteSize.OTHER_SIZE) +\n      \" kb\",\n  };\n}\n \nconsole.log(findInlineScriptsWithNextData());"
    },
    {
        "name": "Resource hints",
        "content": "const rels = [\n  \"preload\",\n  \"prefetch\",\n  \"preconnect\",\n  \"dns-prefetch\",\n  \"preconnect dns-prefetch\",\n  \"prerender\",\n  \"modulepreload\",\n];\n \nrels.forEach((element) => {\n  const linkElements = document.querySelectorAll(`link[rel=\"${element}\"]`);\n  const dot = linkElements.length > 0 ? \"🟩\" : \"🟥\";\n  console.log(`${dot} ${element}`);\n  linkElements.forEach((el) => console.log(el));\n});"
    },
    {
        "name": "Scripts Loading",
        "content": "const scripts = document.querySelectorAll(\"script[src]\");\n \nconst scriptsLoading = [...scripts].map((obj) => {\n  return {\n    src: obj.src,\n    async: obj.async,\n    defer: obj.defer,\n    module: obj.type === 'module',\n    \"render blocking\": obj.async || obj.defer || obj.type === 'module' ? \"\" : \"🟥\",\n  };\n});\n \nconsole.table(scriptsLoading);"
    }
];

InspectorFrontendHost.setPreference("script-snippets", JSON.stringify(importSnippets));
