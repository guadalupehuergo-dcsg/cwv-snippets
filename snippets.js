let importSnippets = [
    {
        "name": "CLS",
        "content": "let cumulativeLayoutShiftScore = 0;\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (!entry.hadRecentInput) {\n      cumulativeLayoutShiftScore += entry.value;\n    }\n  }\n});\n \nobserver.observe({ type: \"layout-shift\", buffered: true });\n \ndocument.addEventListener(\"visibilitychange\", () => {\n  if (document.visibilityState === \"hidden\") {\n    observer.takeRecords();\n    observer.disconnect();\n \n    console.log(`CLS: ${cumulativeLayoutShiftScore}`);\n  }\n});"
    },
    {
        "name": "Get the LCP element",
        "content": "const po = new PerformanceObserver((list) => {\n  let entries = list.getEntries();\n \n  entries = dedupe(entries, \"startTime\");\n \n  entries.forEach((item, i) => {\n    console.dir(item);\n    console.log(\n      `${i + 1} current LCP item : ${item.element}: ${item.startTime}`,\n    );\n    item.element ? (item.element.style = \"border: 5px dotted lime;\") : \"\";\n  });\n \n  const lastEntry = entries[entries.length - 1];\n  console.log(`LCP is: ${lastEntry.startTime}`);\n});\n \npo.observe({ type: \"largest-contentful-paint\", buffered: true });\n \nfunction dedupe(arr, key) {\n  return [...new Map(arr.map((item) => [item[key], item])).values()];\n}"
    },
    {
        "name": "Lazy Images",
        "content": "// List all lazily loaded images above the fold\n// https://webperf-snippets.nucliweb.net\nfunction findAboveTheFoldLazyLoadedImages() {\n  const lazy = document.querySelectorAll('[loading=\"lazy\"]');\n  let lazyImages = [];\n  \n  lazy.forEach((tag) => {\n    const {x, y} = tag.getBoundingClientRect();\n    const position = parseInt(tag.getBoundingClientRect().top);\n \n    if(x < window.innerWidth && y < window.innerHeight && x !== 0 && y !== 0) {\n      lazyImages = [...lazyImages, tag];\n      console.log(tag);\n    }\n  });\n \n  if( lazyImages.length === 0 ) {\n    console.log(\n      `%c Good job, the site does not have any lazily loaded images in the viewport.`,\n      \"background: #222; color: lightgreen; padding: 0.5ch\",\n    );\n  }\n}\n \nfindAboveTheFoldLazyLoadedImages();"
    },
    {
        "name": "LCP SubParts",
        "content": "const LCP_SUB_PARTS = [\n  \"Time to first byte\",\n  \"Resource load delay\",\n  \"Resource load time\",\n  \"Element render delay\",\n];\n \nnew PerformanceObserver((list) => {\n  const lcpEntry = list.getEntries().at(-1);\n  const navEntry = performance.getEntriesByType(\"navigation\")[0];\n  const lcpResEntry = performance\n    .getEntriesByType(\"resource\")\n    .filter((e) => e.name === lcpEntry.url)[0];\n \n  const ttfb = navEntry.responseStart;\n  const lcpRequestStart = Math.max(\n    ttfb,\n    lcpResEntry ? lcpResEntry.requestStart || lcpResEntry.startTime : 0,\n  );\n  const lcpResponseEnd = Math.max(\n    lcpRequestStart,\n    lcpResEntry ? lcpResEntry.responseEnd : 0,\n  );\n  const lcpRenderTime = Math.max(\n    lcpResponseEnd,\n    lcpEntry ? lcpEntry.startTime : 0,\n  );\n \n  LCP_SUB_PARTS.forEach((part) => performance.clearMeasures(part));\n \n  const lcpSubPartMeasures = [\n    performance.measure(LCP_SUB_PARTS[0], {\n      start: 0,\n      end: ttfb,\n    }),\n    performance.measure(LCP_SUB_PARTS[1], {\n      start: ttfb,\n      end: lcpRequestStart,\n    }),\n    performance.measure(LCP_SUB_PARTS[2], {\n      start: lcpRequestStart,\n      end: lcpResponseEnd,\n    }),\n    performance.measure(LCP_SUB_PARTS[3], {\n      start: lcpResponseEnd,\n      end: lcpRenderTime,\n    }),\n  ];\n \n  // Log helpful debug information to the console.\n  console.log(\"LCP value: \", lcpRenderTime);\n  console.log(\"LCP element: \", lcpEntry.element, lcpEntry?.url);\n  console.table(\n    lcpSubPartMeasures.map((measure) => ({\n      \"LCP sub-part\": measure.name,\n      \"Time (ms)\": measure.duration,\n      \"% of LCP\": `${\n        Math.round((1000 * measure.duration) / lcpRenderTime) / 10\n      }%`,\n    })),\n  );\n}).observe({ type: \"largest-contentful-paint\", buffered: true });"
    },
    {
        "name": "LCP Image Entropy",
        "content": "console.table(\n  [...document.images]\n    .filter(\n      (img) => img.currentSrc != \"\" && !img.currentSrc.includes(\"data:image\"),\n    )\n    .map((img) => [\n      img.currentSrc,\n      (performance.getEntriesByName(img.currentSrc)[0]?.encodedBodySize * 8) /\n        (img.width * img.height),\n    ])\n    .filter((img) => img[1] !== 0),\n);"
    },
    {
        "name": "Interactions",
        "content": "const valueToRating = (score) =>\n  score <= 200 ? \"good\" : score <= 500 ? \"needs-improvement\" : \"poor\";\n \nconst COLOR_GOOD = \"#0CCE6A\";\nconst COLOR_NEEDS_IMPROVEMENT = \"#FFA400\";\nconst COLOR_POOR = \"#FF4E42\";\nconst RATING_COLORS = {\n  good: COLOR_GOOD,\n  \"needs-improvement\": COLOR_NEEDS_IMPROVEMENT,\n  poor: COLOR_POOR,\n};\n \nconst observer = new PerformanceObserver((list) => {\n  const interactions = {};\n \n  for (const entry of list\n    .getEntries()\n    .filter((entry) => !entry.interactionId)) {\n    interactions[entry.interactionId] = interactions[entry.interactionId] || [];\n    interactions[entry.interactionId].push(entry);\n  }\n \n  // Will report as a single interaction even if parts are in separate frames.\n  // Consider splitting by animation frame.\n  for (const interaction of Object.values(interactions)) {\n    const entry = interaction.reduce((prev, curr) =>\n      prev.duration >= curr.duration ? prev : curr,\n    );\n    const value = entry.duration;\n    const rating = valueToRating(value);\n \n    const formattedValue = `${value.toFixed(0)} ms`;\n    console.groupCollapsed(\n      `Interaction tracking snippet %c${formattedValue} (${rating})`,\n      `color: ${RATING_COLORS[rating] || \"inherit\"}`,\n    );\n    console.log(\"Interaction target:\", entry.target);\n \n    for (let entry of interaction) {\n      console.log(\n        `Interaction event type: %c${entry.name}`,\n        \"font-family: monospace\",\n      );\n \n      // RenderTime is an estimate, because duration is rounded, and may get rounded down.\n      // In rare cases it can be less than processingEnd and that breaks performance.measure().\n      // Lets make sure its at least 4ms in those cases so you can just barely see it.\n      const adjustedPresentationTime = Math.max(\n        entry.processingEnd + 4,\n        entry.startTime + entry.duration,\n      );\n \n      console.table([\n        {\n          subPartString: \"Input delay\",\n          \"Time (ms)\": Math.round(entry.processingStart - entry.startTime, 0),\n        },\n        {\n          subPartString: \"Processing time\",\n          \"Time (ms)\": Math.round(\n            entry.processingEnd - entry.processingStart,\n            0,\n          ),\n        },\n        {\n          subPartString: \"Presentation delay\",\n          \"Time (ms)\": Math.round(\n            adjustedPresentationTime - entry.processingEnd,\n            0,\n          ),\n        },\n      ]);\n    }\n \n    console.groupEnd();\n  }\n});\n \nobserver.observe({\n  type: \"event\",\n  durationThreshold: 0, // 16 minimum by spec\n  buffered: true,\n});"
    },
    {
        "name": "Layout Shift Loading",
        "content": "new PerformanceObserver((entryList) => {\n  console.log(entryList.getEntries());\n}).observe({ type: \"layout-shift\", buffered: true });"
    },
    {
        "name": "Long Animation Frames",
        "content": "(function init() {\n  function processAndFilterLoAFs(entries) {\n    function floorObject(o) {\n      return Object.fromEntries(\n        Array.from(Object.entries(o)).map(([key, value]) => [\n          key,\n          typeof value === \"number\" ? Math.floor(value) : value,\n        ]),\n      );\n    }\n \n    function processEntry(entry) {\n      const startTime = entry.startTime;\n      const endTime = entry.startTime + entry.duration;\n      const delay = entry.desiredRenderStart\n        ? Math.max(0, entry.startTime - entry.desiredRenderStart)\n        : 0;\n      const deferredDuration = Math.max(\n        0,\n        entry.desiredRenderStart - entry.startTime,\n      );\n      const renderDuration = entry.styleAndLayoutStart - entry.renderStart;\n      const workDuration = entry.renderStart\n        ? entry.renderStart - entry.startTime\n        : entry.duration;\n      const totalForcedStyleAndLayoutDuration = entry.scripts.reduce(\n        (sum, script) => sum + script.forcedStyleAndLayoutDuration,\n        0,\n      );\n      const styleAndLayoutDuration = entry.styleAndLayoutStart\n        ? endTime - entry.styleAndLayoutStart\n        : 0;\n      const scripts = entry.scripts.map((script) => {\n        const delay = script.startTime - script.desiredExecutionStart;\n        const scriptEnd = script.startTime + script.duration;\n        const compileDuration = script.executionStart - script.startTime;\n        const execDuration = scriptEnd - script.executionStart;\n        return floorObject({\n          delay,\n          compileDuration,\n          execDuration,\n          ...script.toJSON(),\n        });\n      });\n      return floorObject({\n        startTime,\n        delay,\n        deferredDuration,\n        renderDuration,\n        workDuration,\n        styleAndLayoutDuration,\n        totalForcedStyleAndLayoutDuration,\n        ...entry.toJSON(),\n        scripts,\n      });\n    }\n \n    return entries.map(processEntry);\n  }\n \n  function analyze() {\n    return loafs\n      .map((loaf) => ({\n        blockingDuration: loaf.blockingDuration,\n        loaf,\n        scripts: loaf.scripts,\n        events: events.filter((e) => overlap(e, loaf)),\n      }))\n      .filter((l) => l.blockingDuration && l.events.length);\n  }\n \n  let loafs = [];\n  let events = [];\n  function processLoAFs(entries) {\n    loafs = [...loafs, ...processAndFilterLoAFs(entries.getEntries())];\n    console.log(analyze());\n  }\n \n  function processEvents(entries) {\n    events = [...events, ...entries.getEntries()];\n    console.log(analyze());\n  }\n  new PerformanceObserver(processLoAFs).observe({\n    type: \"long-animation-frame\",\n    buffered: true,\n  });\n  new PerformanceObserver(processEvents).observe({\n    type: \"event\",\n    buffered: true,\n  });\n \n  function overlap(e1, e2) {\n    return (\n      e1.startTime < e2.startTime + e2.duration &&\n      e2.startTime < e1.startTime + e1.duration\n    );\n  }\n  window.whynp = analyze;\n})();"
    },
    {
        "name": "Long Task",
        "content": "try {\n  const po = new PerformanceObserver((list) => {\n    const numLongTasks = list.getEntries().length;\n    for (const entry of list.getEntries()) {\n      console.table(entry.toJSON());\n    }\n    console.log(\n      `%cNum. Long Tasks: ${numLongTasks}`,\n      \"color: #FF4E42; font-weight: bold\",\n    );\n  });\n  po.observe({ type: \"longtask\", buffered: true });\n} catch (e) {\n  console.error(`The browser doesn't support this API`);\n}"
    },
    {
        "name": "TTFB from Server",
        "content": "// Measure the time to first byte of all the resources loaded\n// https://webperf-snippets.nucliweb.net\nnew PerformanceObserver((entryList) => {\n  const [pageNav] = entryList.getEntriesByType(\"navigation\");\n  console.log(`TTFB (ms): ${pageNav.responseStart}`);\n}).observe({\n  type: \"navigation\",\n  buffered: true,\n});"
    },
    {
        "name": "TTFB Sub Parts",
        "content": "(() => {\n \n  const formatTime = (time) => {\n    //round by 2 decimals, use Math.round() for integer\n    return Math.round(time * 100) / 100;\n  };\n \n  new PerformanceObserver((entryList) => {\n    const [pageNav] = entryList.getEntriesByType('navigation');\n \n    // timing start times are relative\n    const activationStart = pageNav.activationStart || 0;\n    const waitEnd = Math.max((pageNav.workerStart || pageNav.fetchStart) - activationStart, 0);\n    const dnsStart = Math.max(pageNav.domainLookupStart - activationStart, 0);\n    const tcpStart = Math.max(pageNav.connectStart - activationStart, 0);\n    const sslStart = Math.max(pageNav.secureConnectionStart - activationStart, 0);\n    const tcpEnd = Math.max(pageNav.connectEnd - activationStart, 0);\n    const responseStart = Math.max(pageNav.responseStart - activationStart, 0);\n \n    // attribution based on https://www.w3.org/TR/navigation-timing-2/#processing-model\n    // use associative array to log the results more readable\n    let attributionArray = [];\n    attributionArray['Redirect and Waiting duration'] = {'time in ms':formatTime(waitEnd)};\n    attributionArray['Worker and Cache duration'] = {'time in ms':formatTime(dnsStart - waitEnd)};\n    attributionArray['DNS duration'] = {'time in ms':formatTime(tcpStart - dnsStart)};\n    attributionArray['TCP duration'] = {'time in ms':formatTime(sslStart - tcpStart)};\n    attributionArray['SSL duration'] = {'time in ms':formatTime(tcpEnd - sslStart)};\n    attributionArray['Request duration'] = {'time in ms':formatTime(responseStart - tcpEnd)};\n    attributionArray['Total TTFB'] = {'time in ms':formatTime(responseStart)};\n \n    // log the results\n    console.log('%cTime to First Byte ('+formatTime(responseStart - activationStart)+'ms)', 'color: blue; font-weight: bold;');\n    console.table(attributionArray);\n \n    console.log('%cOrigininal navigation entry', 'color: blue; font-weight: bold;');\n    console.log(pageNav);\n \n  }).observe({\n    type: 'navigation',\n    buffered: true\n  });\n})();"
    },
    {
        "name": "TTFB all resources",
        "content": "// Measure the time to first byte of all the resources loaded\n// https://webperf-snippets.nucliweb.net\nnew PerformanceObserver((entryList) => {\n  const entries = entryList.getEntries();\n  const resourcesLoaded = [...entries]\n    .map((entry) => {\n      let obj = {};\n      // Some resources may have a responseStart value of 0, due\n      // to the resource being cached, or a cross-origin resource\n      // being served without a Timing-Allow-Origin header set.\n \n      if (entry.responseStart > 0) {\n        obj = {\n          \"TTFB (ms)\": +entry.responseStart.toFixed(2),\n          Resource: entry.name,\n        };\n      }\n      return Object.keys(obj).length > 0 ? obj : undefined;\n    })\n    .filter((item) => item !== undefined);\n \n  console.table(resourcesLoaded);\n}).observe({\n  type: \"resource\",\n  buffered: true,\n});"
    },
    {
        "name": "Render Blocking Resources",
        "content": "function RenderBlocking({\n  startTime,\n  duration,\n  responseEnd,\n  name,\n  initiatorType,\n}) {\n  this.startTime = startTime;\n  this.duration = duration;\n  this.responseEnd = responseEnd;\n  this.name = name;\n  this.initiatorType = initiatorType;\n}\n \nfunction findRenderBlockingResources() {\n  return window.performance\n    .getEntriesByType(\"resource\")\n    .filter(({ renderBlockingStatus }) => renderBlockingStatus === \"blocking\")\n    .map(\n      ({ startTime, duration, responseEnd, name, initiatorType }) =>\n        new RenderBlocking({\n          startTime,\n          duration,\n          responseEnd,\n          name,\n          initiatorType,\n        }),\n    );\n}\n \nconsole.table(findRenderBlockingResources());"
    },
    {
        "name": "Resourse hints",
        "content": "const rels = [\n  \"preload\",\n  \"prefetch\",\n  \"preconnect\",\n  \"dns-prefetch\",\n  \"preconnect dns-prefetch\",\n  \"prerender\",\n  \"modulepreload\",\n];\n \nrels.forEach((element) => {\n  const linkElements = document.querySelectorAll(`link[rel=\"${element}\"]`);\n  const dot = linkElements.length > 0 ? \"🟩\" : \"🟥\";\n  console.log(`${dot} ${element}`);\n  linkElements.forEach((el) => console.log(el));\n});"
    },
    {
        "name": "Script snippet #15",
        "content": "const scripts = document.querySelectorAll(\"script[src]\");\nconst scriptsLoading = [...scripts].map((obj) => {\n  return {\n    src: obj.src,\n    async: obj.async,\n    defer: obj.defer,\n    module: obj.type === 'module',\n    \"render blocking\": obj.async || obj.defer || obj.type === 'module' ? \"\" : \":large_red_square:\"\n  };\n});\nconsole.table(scriptsLoading);"
    }
];

InspectorFrontendHost.setPreference("script-snippets", JSON.stringify(importSnippets));